%%%%%%%%%%%%%%%%%%%%此程序为黄耿第自创，敬请指出不足之处或共同探讨，随意借鉴，但谢绝抄袭%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%3DES解密算法，正确性已验证，其中密文为64位二进制，密钥为128位二进制，待改进为读进十六进制转换
%%%%%%%%%%%%%%%%%%%%%%%%为二进制，2011.6.9%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [C_DES] = n3des(M,K)%%%%%%%%%%%%%%%%%%%%%%%%  M为密文，K为密钥
m=zeros(1,64);%%%%%%%%%%%%%%%%%%%%%%%初始化中间变量
ER=zeros(1,48);%%%%%%%%%%%%%%%%%%%初始化中间变量
SSS=zeros(1,32);%%%%初始化中间变量
SST=zeros(1,32);%%%%%初始化中间变量
IP=[58 50 42 34 26 18 10 2 60 52 44 36 28 20 12 4 62 54 46 38 30 22 14 6 64 ...
    56 48 40 32 24 16 8 57 49 41 33 25 17 9 1 59 51 43 35 27 19 11 3 61 53 ...
    45 37 29 21 13 5 63 55 47 39 31 23 15 7];IP=[58 50 42 34 26 18 10 2 60 ...
    52 44 36 28 20 12 4 62 54 46 38 30 22 14 6 64 56 48 40 32 24 16 8 57 49 ...
    41 33 25 17 9 1 59 51 43 35 27 19 11 3 61 53 45 37 29 21 13 5 63 55 47 39 31 23 15 7];
IP_1=[40 8 48 16 56 24 64 32 39 7 47 15 55 23 63 31 38 6 46 14 54 22 62 30 ...
    37 5 45 13 53 21 61 29 36 4 44 12 52 20 60 28 35 3 43 11 51 19 59 27 ...
    34 2 42 10 50 18 58 26 33 1 41 9 49 17 57 25];
E=[32 1 2 3 4 5 4 5 6 7 8 9 8 9 10 11 12 13 12 13 14 15 16 17 16 17 18 19 20 ...
    21 20 21 22 23 24 25 24 25 26 27 28 29 28 29 30 31 32 1];
S1=[14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7;
    0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8;
    4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0;
    15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13];
S2=[15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10;
    3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5;
    0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15;
    13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9];
S3=[10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8;
    13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1;
    13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7;
    1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12];
S4=[7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15;
    13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9;
    10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4;
    3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14];
S5=[2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9;
    14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6;
    4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14;
    11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3];
S6=[12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11;
    10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8;
    9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6;
    4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13];
S7=[4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1;
    13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6;
    1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2;
    6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12];
S8=[13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7;
    1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2;
    7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8;
    2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11];
SPD=[0 0 0 0;0 0 0 1;0 0 1 0;0 0 1 1;0 1 0 0;0 1 0 1; 0 1 1 0;0 1 1 1 ;...%%%%%%%%%%%%%%%%此SPD矩阵为S盒中的数据
    1 0 0 0 ;1 0 0 1;1 0 1 0;1 0 1 1;1 1 0 0; 1 1 0 1; 1 1 1 0;1 1 1 1];%%%%%%%%%%%%%%%%%%转为二进制数做准备
P=[16,7,20,21,29,12,28,17,1,15,23,26,5,18,31,10,2,8,24,14,32,27,3,9,19,13,30,6,22,11,4,25];
C_DES=zeros(1,64);%%%%%%%%%%%%%%%%%%%%%%%初始化明文
C_DES = M;
for des_3n = 1:3
    for i=1:64               %%%%%%%%%%%%%%%%%%%%%%此for循环完成IP置换
        m(i)=C_DES(IP(i));
    end
    LLL=m(1:32);%%%%%%%%%
    R=m(33:64);%%%%%%%%%分解为左右两部分
    for n=1:16%%%%%%%%%%%%进行16此迭代运算
        for j=1:48   %%%%%%%%%%%%%%%%%进行E扩展成48位二进制数
            ER(j)=R(E(j));
        end
        if (des_3n == 1 || des_3n == 3)         %%%%%%%%%%%%%%%%3DES解密过程
            K_DES = K(1:64);
            nn = 17 - n;
        elseif (des_3n == 2)
              K_DES = K(65:128);
              nn = n;
        end
        key= miyaodes(K_DES,nn); %调用密钥函数，其中n代表迭代运算的第几次
        RR=bitxor(ER,key);%%%%%%%%%%%%%进行异或运算
        for p=1:8          %%%%%%%%%%%%%%%%%%%根据前一步得到48位二进制数，分解为8个单位，分别进行8个S盒输出
            st=(p-1)*6;    %%%%%%%%%%%%st为0 6 12 ……56，进行加一运算即分别为八个6位二进制数的第一个数字
            H=RR(st+1)*2+RR(st+6)+1; %%%%%%%%%%%%%%%%%%%判断属于S盒的哪一行
            L=RR(st+2)*8+RR(st+3)*4+RR(st+4)*2+RR(st+5)+1; %%%%%%%%%%%%%%%%%%%%5判断属于S盒的哪一列
            if(p==1)
                SSS1=SPD(S1(H,L)+1,:);                      %%%%%%%%%%%此if判断语句根据得到的对应的S盒数据，
            elseif(p==2)                                     %%%%%%%%%进行十进制数和二进制数的转换
                SSS2=SPD(S2(H,L)+1,:);
            elseif(p==3)
                SSS3=SPD(S3(H,L)+1,:);
            elseif(p==4)
                SSS4=SPD(S4(H,L)+1,:);
            elseif(p==5)
                SSS5=SPD(S5(H,L)+1,:);
            elseif(p==6)
                SSS6=SPD(S6(H,L)+1,:);
            elseif(p==7)
                SSS7=SPD(S7(H,L)+1,:);
            elseif(p==8)
                SSS8=SPD(S8(H,L)+1,:);
            end
        end
        SSS=[SSS1,SSS2,SSS3,SSS4,SSS5,SSS6,SSS7,SSS8];%%%%%%%%%%%%%%%将分散的8个四位二进制重排成32位数据
        for i=1:32                 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%进行P位置换
            SST(i)=SSS(P(i));
        end
        LX=bitxor(LLL,SST);     %%%%%%%%%%%%%%%%%%%%%%%完成f函数后，与左半部分的数据异或
        LM=[LX,R];              %%%%%%%%%%%%%%%%%%%%%%生成新的序列
        if(n<16)                %%%%%%%%%%%%%%%%%%%%%判断迭代函数是不是进行到了第16次，未达到16次则进行交换
            LM=[R,LX];              %%%%%%%%%%%%%%%%%%%
            LLL=LM(1:32);          %%%%%%%%%%%%%%%%%%%%%将得到的数据分为左右边，用于下一次迭代运算
            R=LM(33:64);
        end
    end
    for p=1:64 
        C_DES(p)=LM(IP_1(p));
    end           %%%%%%%%%%%%%%%%%%%%%%%%迭代运算完成后，进行IP逆置换，得到密文，至此，解密过程完毕
end   
    
    
    
